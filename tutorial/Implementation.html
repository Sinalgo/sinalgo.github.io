<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!--suppress CheckImageSize -->
<html>
<head>
    <title>Sinalgo</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="keywords"
          content="roger wattenhofer, wattenhofer, distributed computing, simulation, network algorithm, validation, Sinalgo">
    <link REL="SHORTCUT ICON" href="../pics/favicon.ico">
    <link rel=stylesheet href="../style.css" type="text/css">


    <script type="text/javascript" language="JavaScript"><!--
    function setup() {
        if (!document.all) {
            document.getElementById("menu").style.top = window.pageYOffset.toString();
        }
        if (document.all) {
            document.all["menu"].style.top = document.body.scrollTop.toString();
        }
        window.setTimeout("setup()", 10);
    }

    //-->
    </script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=UA-120259448-1"></script>
    <script type="text/javascript">
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }

        gtag('js', new Date());

        gtag('config', 'UA-120259448-1');
    </script>


</head>

<body class="text" bgcolor="#FFFFFF" onload="setup()">
<table align="center" width="100%" style="margin-bottom:0"
       cellpadding="0" cellspacing="0" border="0">
    <tr class="height80">
        <td><img src="../pics/spacer.gif" width="210" height="80"
                 alt=""></td>
        <td width="100%">
            <h1 align="center">Sinalgo - <span class="red">Si</span>mulator for <span class="red">N</span>etwork <span
                    class="red">Algo</span>rithms</h1>
        </td>
    </tr>
    <tr class="height2">
        <td colspan="2" class="horizontalLine"></td>
    </tr>
</table>

<table border="0" cellspacing="0" cellpadding="0" class="showEmptyCells">
    <tr class="height10">
        <td width="210"></td>
        <td width="2" class="verticalLine"><img src="../pics/blac_vert_line.gif"
                                                width="2" height="1" alt=""></td>
        <td></td>
        <td colspan="2" align="right" valign="bottom"></td>
    </tr>

    <tr valign="top">
        <td>
            <div id='menu' style='position:absolute; visibility:visible; top:0;'>
                <table border="0" cellspacing="0" width="210">
                    <tr class="height80">
                        <td><a href="http://disco.ethz.ch/" target="_blank"><img
                                src="../pics/dcgWhite.png"
                                alt="Distributed Computing Group" border="0" height="50" width="160"></a></td>
                    </tr>
                    <tr class="height30">
                        <td><img src="../pics/spacer.gif" width="210" height="1" alt="">
                        <td>
                    </tr>
                    <tr>
                        <td class='menu'><a href='../index.html' class='menuLink'>Home</a></td>
                    </tr>
                    <tr>
                        <td class='menu'><a href='../news.html' class='menuLink'>News</a></td>
                    </tr>
                    <tr>
                        <td class='menu'><a href='../download.html' class='menuLink'>Download</a></td>
                    </tr>
                    <tr>
                        <td class='menu'><a href='Documentation.html' class='menuLink'>Tutorial</a></td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Documentation.html' class='SubMenuLink'>Getting
                            Started</a></td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Installation.html' class='SubMenuLink'>Installation</a>
                        </td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Execution.html' class='SubMenuLink'>Execution</a></td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Project.html' class='SubMenuLink'>Projects</a></td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Implementation.html' class='selected_SubMenuLink'>Node
                            Implementation</a></td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Implementation.html#Sync Call Sequence'
                                                  class='SubSubMenuLink'>Sync Call Sequence</a></td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Implementation.html#Async Call Sequence'
                                                  class='SubSubMenuLink'>Async Call Sequence</a></td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Implementation.html#Node Behavior'
                                                  class='SubSubMenuLink'>Node Behavior</a></td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Implementation.html#Popup Menu' class='SubSubMenuLink'>Popup
                            Menu</a></td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Implementation.html#Messages'
                                                  class='SubSubMenuLink'>Messages</a>
                        </td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Implementation.html#Inbox'
                                                  class='SubSubMenuLink'>Inbox</a></td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Implementation.html#NackBox' class='SubSubMenuLink'>NackBox</a>
                        </td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Implementation.html#Edges'
                                                  class='SubSubMenuLink'>Edges</a></td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Implementation.html#Timers' class='SubSubMenuLink'>Timers</a>
                        </td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Implementation.html#CustomGlobal'
                                                  class='SubSubMenuLink'>CustomGlobal</a></td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Models.html' class='SubMenuLink'>Model Implementation</a>
                        </td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Configuration.html' class='SubMenuLink'>Configuration</a>
                        </td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Tools.html' class='SubMenuLink'>Tools</a></td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Architecture.html' class='SubMenuLink'>Architecture</a>
                        </td>
                    </tr>
                    <tr>
                        <td class='menu'><a href='../faq.html' class='menuLink'>FAQ</a></td>
                    </tr>
                    <tr>
                        <td class='menu'><a href='../contact.html' class='menuLink'>Contact</a></td>
                    </tr>
                </table>
            </div>
            <img src="../pics/spacer.gif" width="210" height="1" alt="">
        </td>
        <td width="2" class="verticalLine"><img src="../pics/blac_vert_line.gif"
                                                width="2" height="1" alt=""></td>
        <td><img src="../pics/spacer.gif" width="30" height="1" alt=""></td>

        <td class="bodyText" width="100%">

            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
            <h1>Node Implementation</h1>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            The implementation of a project consists of several tasks:

            <ul class="unstyled extra-space">
                <li>Implement the node behavior</li>
                <li>Implement additional models as needed</li>
                <li>Configure the project using the configuration file</li>
            </ul>

            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
            <h2>Node Basics</h2>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            Each simulated node is an instance of a subclass of <span
                class="code">sinalgo.nodes.Node</span>. Each node has its proper
            instances of the Mobility, Connectivity, Interference, and
            Reliability model. These four model instances are created when the
            node is created. The Message Transmission Model is globally unique,
            and the distribution model is only used to initially place the nodes
            and is created for each set of generated nodes.

            <p>As in reality, the nodes implement their own behavior. Among
                others, they have a method that is called when the node receives a
                message, and they implement the functionality to send messages to
                neighboring nodes. Depending on the simulation mode, the node's
                methods are called in a slightly different way. The following shows a
                high-level picture of the calling-sequences of the synchronous and
                asynchronous mode, which are described in more detail in the <a
                        href="Architecture.html#Sync vs Async"
                        class="nav_link">Architecture</a> section of this tutorial.

            <div class="subsubBody">
                <h3>Calling Sequence in Synchronous Simulation<a name="Sync Call Sequence"></a></h3>
                <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

                In the synchronous simulation mode, the framework performs the
                following actions for each <strong>round</strong>. Bold text indicates methods that
                you may overwrite or implement to define the behavior of the network
                nodes and the simulation. Note that the execution is strictly sequential,
                i.e. a single thread executes the following actions. As a result, no
                synchronization is needed to access global information.

                <ol class="unstyled extra-space">
                    <li>The framework increments the global time by 1.</li>
                    <li><span class="code"><strong>CustomGlobal.preRound();</strong></span> <em class="smallBodyText">(Optional,
                        project specific code. This method is called at the beginning of every round.)</em></li>

                    <li>The framework handles <strong>global timers</strong> that fire in this round.</li>

                    <li>The framework moves the nodes according to their <strong>mobility models</strong>, if mobility
                        is enabled.
                    </li>

                    <li>The framework calls each node to update its set of outgoing connections according to its
                        <strong>connectivity
                            models</strong>.
                    </li>

                    <li>The framework calls <strong>interference</strong> tests for all messages being sent, if
                        interference is
                        enabled.
                    </li>

                    <li>The framework iterates over all nodes and calls <span
                            class="code">Node.<strong>step()</strong></span> on each node. <em class="smallBodyText">
                        The method
                        'step' performs the following
                        actions for each node:</em><br>

                        <ol class="unstyled extra-space">
                            <li>The node gathers all messages that arrive in this round.</li>
                            <li><span class="code"><strong>Node.preStep();</strong></span> <em class="smallBodyText">(Optional,
                                project specific code. This method is called at the beginning of very step.)</em></li>
                            <li>If this node's set of outgoing connections has changed in this round, the node calls
                                <span class="code"><strong>Node.neighborhoodChange();</strong></span></li>
                            <li>The node handles <strong>timers</strong> that fire in this round.</li>
                            <li><span class="code"><strong>Node.handleNAckMessages();</strong></span> <em
                                    class="smallBodyText">(Handle
                                dropped messages, if</em> <span class="code">generateNAckMessages</span><em
                                    class="smallBodyText"> is enabled.)</em></li>
                            <li><span class="code"><strong>Node.handleMessages();</strong></span> <em
                                    class="smallBodyText">(Handle
                                the arriving messages.)</em></li>
                            <li><span class="code"><strong>Node.postStep();</strong></span> <em class="smallBodyText">(Optional,
                                project specific code. This method is called at the end of each step.)</em></li>
                        </ol>

                    </li>

                    <li><span class="code"><strong>CustomGlobal.postRound();</strong></span> <em class="smallBodyText">(Optional,
                        project specific code. This method is called at the end of every round.)</em></li>

                    <li>If <span class="code"><strong>CustomGlobal.hasTerminated();</strong></span> returns true, the
                        simulation
                        exits.
                    </li>
                </ol>

            </div>

            <div class="subsubBody">
                <h3>Events in Asynchronous Simulation<a name="Async Call Sequence"></a></h3>
                <!-- - - - - - - - - - - - - - - -->

                In asynchronous simulation mode, there are only two events upon which
                nodes react: Arriving messages and timer events. Thus, only the
                methods <span class="code">Node.<strong>handleMessages()</strong></span>,
                (<span class="code">Node.<strong>handleNAckMessages()</strong></span>), and
                <span class="code">Timer.<strong>fire()</strong></span> are called. Before
                performing a scheduled event, the global time of the system is set to
                the time when the event happens.

                <p>Remember that mobility is not possible in the asynchronous
                    mode. However, the messages may be checked for interference if
                    interference is turned on in the configuration file.
            </div>


            <h2>Node Behavior<a name="Node Behavior"></a></h2>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            To implement the node behavior (this includes your algorithm), create
            a class which inherits from <span class="code">sinalgo.nodes.Node</span>
            and place the source file in the <span
                class="code">node/nodeImplementation/</span> folder of your
            project. Implement the method <span
                class="code"><strong>Node.handleMessages();</strong></span> and optionally any
            of the other abstract methods from the <span
                class="code">sinalgo.nodes.Node</span> class.

            <p>The following list gives the most useful members of the <span
                    class="code">sinalgo.nodes.Node</span> class you may use. For a complete
                description of their functionality, refer to the documentation in the
                code.

            <p>
            <table border="1" cellpadding="5" cellspacing="0">
                <tr>
                    <td colspan="2"><strong>Public Member Variables</strong></td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        int ID
                    </td>
                    <td>
                        Each node is assigned a unique ID when it is created. This ID may be used to distinguish the
                        nodes.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        Connections outgoingConnections;
                    </td>
                    <td>
                        A collection of all edges outgoing from this node. Note that all edges are directed, the
                        bidirectional edges just ensure that there is an edge in both directions.
                    </td>
                </tr>

                <tr>
                    <td colspan="2"><strong>Methods</strong></td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        void send(Message m, int target) throws NoConnectionException;
                    </td>
                    <td>
                        Sends a message to a neighbor node with the default intensity of the node.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        void send(Message m, int target, double intensity) throws NoConnectionException;
                    </td>
                    <td>
                        Sends a message to a neighbor node with the given intensity.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        void send(Message m, Node target) throws NoConnectionException;
                    </td>
                    <td>
                        Sends a message to a neighbor node with the default intensity of the node.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        void send(Message m, Node target, double intensity) throws NoConnectionException;
                    </td>
                    <td>
                        Sends a message to a neighbor node with the given intensity.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        void sendDirect(Message msg, Node target);
                    </td>
                    <td>
                        Sends a message to any node in the network, independent of whether there is a connection between
                        the two nodes or not.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        void broadcast(Message m);
                    </td>
                    <td>
                        Broadcasts a message to all neighboring nodes with the default intensity of the node.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        void broadcast(Message m, double intensity);
                    </td>
                    <td>
                        Broadcasts a message to all neighboring nodes with the given intensity.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        Position getPosition();
                    </td>
                    <td>
                        Returns the current position of the node.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        TimerCollection getTimers();
                    </td>
                    <td>
                        Returns a collection of all timers currently active at the node.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        void setRadioIntensity(double i);
                    </td>
                    <td>
                        Sets the radio intensity of the node.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        double getRadioIntensity();
                    </td>
                    <td>
                        Gets the radio intensity of the node.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        void setColor(Color c);
                    </td>
                    <td>
                        Sets the color in which the node is painted on the GUI.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        Color getColor();
                    </td>
                    <td>
                        Gets the color in which the node is painted on the GUI.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        void draw(...);
                    </td>
                    <td>
                        Implements how the node is drawn on the GUI. You may overwrite this method in your subclass
                        of <span class="code">sinalgo.node.Node</span> to define a customized drawing.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        void drawAsDisk(..., int sizeInPixels);
                    </td>
                    <td>
                        A helper method provided by <span class="code">sinalgo.node.Node</span> that draws the node
                        as a disk. Call this method in your <span class="code">draw(...)</span> method.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        void drawNodeWithText(..., String text, int fontSize, Color textColor);
                    </td>
                    <td>
                        A helper method provided by <span class="code">sinalgo.node.Node</span> that draws the node
                        as a disk and with text. Call this method in your <span class="code">draw(...)</span> method.
                    </td>
                </tr>

                <tr>
                    <td valign="top" class="code">
                        void drawToPostScript(...);
                    </td>
                    <td>
                        Implements how the node is exported to PostScript. You may overwrite this method in your
                        subclass
                        of <span class="code">sinalgo.node.Node</span> to define a customized drawing to PostScript.
                    </td>
                </tr>

            </table>
            <span class="caption">Methods of the superclass <span class="code">sinalgo.nodes.Node</span> you may use to implement the node behavior.</span>


            <p>To control the creation of a node object, the super-class provides
                the two methods <span class="code">init()</span> and <span
                        class="code">checkRequirements()</span> which you may overwrite in
                your subclass:

                <br><span class="code">Node.<strong>init()</strong></span> is called once at the
                beginning of the lifecycle of a node object. It may be used to
                initialize the start state of the node. Note that this function may
                not depend on the neighborhood of the node as the init function is
                called before the connections are set up and before the set of all
                nodes is available.

                <br><span class="code">Node.<strong>checkRequirements()</strong></span> is called
                after the init() method to check whether all requirements to use this
                node type are met. This may include a test whether appropriate models
                have been selected.


            <h2>Project Specific Popup Methods<a name="Popup Menu"></a></h2>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            To facilitate interaction in the GUI mode, you may register methods
            of your <span class="code">Node</span> subclass to a popup menu that
            shows up when the user right-clicks on a node.

            <table border="0" width="100%">
                <tr>
                    <td>

                        The annotation <span
                            class="code">@NodePopupMethod(menuText="XXX")</span> in the following
                        code sample declares the method <span
                            class="code">myPopupMenu()</span> to be included in the popup menu
                        with the menu text <span class="code">XXX</span>. Note that the
                        methods to register with the popup menu may not take any parameters
                        and need to be located in the source-file of the specific <span
                            class="code">Node</span> subclass.

                        <p>
                        <div class="code codeTab">
                            @NodePopupMethod(menuText="Multicast 2")<br>
                            <strong>public</strong> <strong>void</strong> myPopupMethod() {<br>
                            <div class="codeTab">IntMessage msg = <strong>new</strong> IntMessage(2);<br>
                                MessageTimer timer = <strong>new</strong> MessageTimer(msg);<br>
                                timer.startRelative(1, <strong>this</strong>);
                            </div>
                            }
                        </div>
                    </td>
                    <td align="center"><img src="../pics/popup.png" alt="Image of popup menu">
                        <br><span class="caption">Customized node popup menu</span>
                    </td>
                </tr>
            </table>

            <p>The sample code generates a message carrying an int-value, and
                broadcasts it to all its neighbors. Note that the method does not
                broadcast the message directly, but creates a timer, which will be
                triggered in the next round when the node performs its step. This is
                necessary for the synchronous simulation mode, because nodes are only
                allowed to send messages while they are executing their <a
                        class="nav_link"
                        href="Implementation.html#Sync Call Sequence">step</a>. However,
                the user can only interact with the GUI while the simulation is not
                running. Therefore, the methods called through the popup menu always
                execute when the simulation is stopped. The preferred solution is to
                create a timer which fires in the next round and performs the desired
                action.

            <p><strong>Note:</strong> The <span class="code">MessageTimer</span> is
                available in the <span class="code">defaultProject</span>. This timer
                may send a unicast message to a given node, or multicast a message to
                all immediate neighbors. Please consult the documentation of the
                source code for more details.

            <p>In some cases, it may be desirable to determine only at runtime the set of
                methods to be included in the menu, and on their menu text. This is possible
                because the popup menu for the node is assembled every time the user right-clicks
                on a node. The framework includes all methods annotated with the <span class="code">NodePopupMenu</span>
                annotation of the corresponding node class. But before including such a method
                in the list, the framework calls the node-method
                <span class="code">includeMethodInPopupMenu(Method m, String defaultText)</span>,
                which allows to decide at runtime whether the menu should be included or not, and,
                change the menu text if necessary.

            <p>To obtain control over the included menu entries, overwrite the
                <span class="code">includeMethodInPopupMenu(Method m, String defaultText)</span>
                method in your node subclass. Return <span class="code">null</span> if the method
                should not be included, otherwise the menu text to be displayed.

            <h2>Messages<a name="Messages"></a></h2>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            Nodes communicate by the means of messages. To implement your own
            message class, derive from <span
                class="code">sinalgo.nodes.messages.Message</span> and place your source
            file in the <span class="code">nodes/messages/</span> folder of your
            project.

            <p>The abstract class <span class="code">Message</span> requires you
                to implement a single method that returns a clone of the message,
                i.e. an exact <em>copy</em> of the message object:<br> <span
                        class="code codeTab"><strong>public</strong> Message clone()</span>

            <p class="note"><strong>Implementation Note:</strong> When a node sends a
                message to a neighbor node, it is assumed that the destination
                receives the message-content that was sent through the <span
                        class="code">send()</span> method. The framework has however no means
                to test whether the sender still has a reference to the sent
                message-object, and therefore may be able to alter its content. To
                avoid such problems, the framework sends separate copies to all
                receivers of a send() or multicast() call. Thus, for a multicast to
                <em>n</em> neighbors, the framework obtains <em>n</em> copies of the
                message and sends a copy to each of the neighbors.
            </p>

            <p>If <strong>and only if</strong> your project ensures that a message-object
                is not altered after it was sent, you may omit the copying process by
                providing the following implementation of the <span
                        class="code">clone()</span> method. (Note that the process of sending
                or receiving a message does not alter the message-object. Thus, a
                node may safely forward the same message-object it has received.)<br>

            <div class="code codeTab">
                <strong>public</strong> Message clone() {<br>
                <div class="codeTab"><strong>return this</strong>;<em>// This message requires a read-only policy</em>
                </div>
                }
            </div>

            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
            <h2>Inbox / handleMessages()<a name="Inbox"></a></h2>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            Each node stores the messages it receives in an instance of the <span
                class="code">Inbox</span> class. The inbox provides an iterator-like
            view over the set of messages that are received in the current round
            in synchronous simulation mode. In asynchronous simulation mode, the
            inbox contains only the single message that triggered the event. The
            method <span class="code">handleMessages(Inbox inbox)</span> provides
            this inbox as single parameter.

            <p>For each received message, this iterator stores meta-information,
                such as the sender of the message. This meta-information is available
                for the packet that was last returned through the <span class="code">next()</span>
                method.

            <p>In order to iterate several times over the set of packets, you may
                reset the inbox by calling <span class="code">reset()</span>, <span
                        class="code">size()</span> returns the number of messages in the
                inbox. Call <span class="code">remove()</span> to remove the message
                from the inbox that was returned by the last call to <span
                        class="code">next()</span>.

            <p>Typically, a node iterates over all messages in the inbox with the
                following code:

            <p>
            <div class="code codeTab">
                <strong>while</strong>(inbox.hasNext()) {<br>
                <div class="codeTab">Message msg = inbox.next();<br>
                    <strong>if</strong>(msg <strong>instanceof </strong>...) {<br>
                    <div class="codeTab"><em>\\ handle this type of message</em></div>
                    }
                </div>
                }
            </div>


            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
            <h2>NackBox / handleNAckMessages()<a name="NackBox"></a></h2>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            Messages may be dropped, due to changes to the connectivity graph,
            interference, or the message transmission model. The framework
            provides a means to inform the sender node whenever a <em>unicast</em>
            message sent by the node does not reach the destination. This is an
            optional feature that needs to be enabled through the project
            configuration: set the entry <span
                class="code">generateNAckMessages</span> to true. If your project
            does not drop messages at all, or if your nodes are not interested in
            this information, you should disable this feature to speed up the
            simulation.

            <p>In asynchronous simulation mode, messages are kept in
                message-events, which are scheduled to execute when the message is
                supposed to arrive. At the time of execution, the framework decides
                whether the message arrives. If the message arrives, the method <span
                        class="code">handleMessages()</span> is called on the receiver
                node. If the message does not arrive, the method <span
                        class="code">handleNAckMessages()</span> is called on the sender
                node.

            <p>In synchronous simulation mode, a sender node can handle the set
                of messages that were scheduled to arrive in the previous round, but
                were dropped. The method <span
                        class="code">handleNAckMessages()</span> is called prior to handling
                the messages that arrive on the node, and passes on the set of
                dropped messages.

            <p>The use of the <span class="code">NackBox</span> object, which
                holds the set of dropped messages, is equivalent to the <span
                        class="code">Inbox</span>.


            <p>A typical implementation of the <span
                    class="code">handleNAckMessages()</span>, which needs to be added to
                your node implementation if you want to use this feature, looks as
                following:

            <p>
            <div class="code codeTab">
                <strong>public void</strong> handleNAckMessages(NackBox nackBox) {
                <div class="codeTab"><strong>while</strong>(nackBox.hasNext()) {<br>
                    <div class="codeTab">Message msg = nackBox.next();<br>
                        <strong>if</strong>(msg <strong>instanceof </strong>...) {<br>
                        <div class="codeTab"><em>\\ handle this type of message</em></div>
                        }
                    </div>
                    }
                </div>
                }
            </div>

            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
            <h2>Edges<a name="Edges"></a></h2>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            Nodes are connected by edges. Most projects may be happy with the
            default edge implementation (which is unidirectional!) or one of the
            implementations provided in the <span
                class="code">defaultProject</span>. If you need a more specialized
            edge, create a subclass from <span
                class="code">sinalgo.nodes.edges.Edge</span> and put the source file in
            the <span class="code">nodes/edges/</span> folder of your project.

            <p><strong>Note:</strong> The framework only supports one edge type at any
                time. The type to use can be specified in the configuration file, and
                it may be switched at runtime through the <span
                        class="code">Preferences</span> menu. Changing the edge type at
                runtime only affects edges created after the change. It does not
                replace the already existing edges.

            <p>The following edges are already available:

            <table border="1" cellpadding="5" cellspacing="0">
                <tr>
                    <td valign="top"><span class="code">
sinalgo.nodes.edges.Edge
</span></td>
                    <td>

                        The default edge implementation, superclass of all edges. This edge
                        is directional. As a result, Sinalgo does not really support
                        bidirectional edges in the sense that there is a single object for a
                        bidirectional edge. The bidirectional edge implementation solves this problem
                        by adding an edge in both directions.
                        <br>By default, this edge draws itself as a black line between the
                        two end-nodes, and colors itself red when a message is sent over the
                        edge.
                    </td>
                </tr>

                <tr>
                    <td valign="top"><span class="code">
sinalgo.nodes.edges.BidirectionalEdge
</span></td>
                    <td>
                        The default bidirectional edge implementation. It ensures that there is an edge
                        in both directions between the two end nodes.
                        <br>By default, this edge draws itself as a black line between the
                        two end-nodes, and colors itself red when a message is sent over the
                        edge.
                    </td>
                </tr>

                <tr>
                    <td valign="top"><span class="code">
projects.defaultProject.nodes<br>.edges.BooleanEdge
</span></td>
                    <td>

                        The BooleanEdge extends the default edge implementation with a
                        boolean member <span class="code">flag</span> that may be used
                        arbitrarily. It also carries a static member <span
                            class="code">onlyUseFlagedEdges</span>, which may be used to enable
                        or disable globally the use of the flag.

                        <br>The provided implementation uses <span
                            class="code">onlyUseFlagedEdges</span> and <span
                            class="code">flag</span> to decide whether the edge is drawn or not:
                        If <span class="code">onlyUseFlagedEdges</span> is <span
                            class="code">true</span>, the edge only draws itself if <span
                            class="code">flag</span> is set to <span class="code">true</span>.
                    </td>
                </tr>

                <tr>
                    <td valign="top"><span class="code">
projects.defaultProject.nodes<br>.edges.BidirectionalBooleanEdge
</span></td>
                    <td>
                        A bidirectional edge with the features of the boolean edge.
                    </td>
                </tr>

                <tr>
                    <td valign="top"><span class="code">
projects.defaultProject.nodes<br>.edges.GreenEdge
</span></td>
                    <td>
                        The same as the default edge implementation, but it draws itself as a
                        green line between the two end-nodes.
                    </td>
                </tr>
            </table>
            <span class="caption">Edge implementations which are available by default.</span>

            To manually insert a connection from node <span class="code">u</span>
            to node <span class="code">v</span>, you may use
            the method <span class="code">u.addConnectionTo(v)</span>. Project sample6
            demonstrates how a static network may be built.

            <h2>Timers<a name="Timers"></a></h2>
            <!-- - - - - - - - - - - - - - - -->

            A timer is an object that allows a node to schedule a task in the
            future. When the task is due, the timer wakes up the node and
            performs the given task. Any timer object is a subclass of <span
                class="code">sinalgo.nodes.timers.Timer</span> and implements the method
            <span class="code"><strong>void</strong> fire()</span>, which contains the task
            this timer needs to perform.

            <p>To write a project specific timer, implement a subclass of <span
                    class="code">sinalgo.nodes.timers.Timer</span> and put the source file
                in the <span class="code">nodes/timers/</span> folder of your
                project. A timer instance is started by calling either the <span
                        class="code">startAbsolute(double absoluteTime, Node n)</span> method
                or the <span class="code">startRelative(double relativeTime, Node
 n)</span> method of the super class. The time specifies when the task
                should be scheduled, and the node specifies the node on which the
                task should be executed.

            <p><strong>Hint:</strong> The default project provides a <span
                    class="code">MessageTimer</span> that schedules to send a message at
                a given time. The message may be unicast to a specified recipient, or
                multicast to all immediate neighbors.</p>

            <div class="subsubBody">
                <h3>Global Timers</h3>
                <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

                A timer object can also be used to perform a task for the simulation
                framework at a given time. Such a global task is not executing
                on a particular node, and is suited to perform simulation specific
                tasks (e.g. add/drop some nodes, select a random node to perform
                an action, change the network, ...) In synchronous simulation mode,
                the global timers are handled after the
                <span class="code">CustomGlobal.preRound()</span> method. In
                asynchronous simulation mode, a global timer becomes an event that
                executes when the simulation time reached the execution time of the
                timer.

                <p>To create a global timer, implement a subclass of <span
                        class="code">sinalgo.nodes.timers.Timer</span> just as for the
                    regular node timers. But in contrast to the node related timers, start
                    the timer with its method <span class="code">startGlobalTimer(double relativeTime)</span>.

                <p><strong>Hint:</strong> You may use the same timer implementation as a node-related timer and
                    as a global timer. Just make sure that the <span class="code">fire()</span>
                    method of the timer class does not access the <span class="code">node</span> member
                    when the timer was started as a global timer. This member is set only when the
                    timer is started as a node-related timer.
            </div>

            <h2>Customized, Globally Visible Methods: CustomGlobal.java<a name="CustomGlobal"></a></h2>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            Each project comes with a <span class="code">CustomGlobal</span>
            class, which collects global methods specific to the project. This
            class extends <span
                class="code">sinalgo.runtime.AbstractCustomGlobal</span> and is located
            in the root folder of your project.

            The following table gives an overview of the methods you may
            overwrite in your project specific <span
                class="code">CustomGlobal.java</span>. (These methods are defined in
            the abstract superclass <span
                class="code">AbstractCustomGlobal.java</span> with an empty body.)

            <table border="1" cellpadding="5" cellspacing="0">
                <tr>
                    <td valign="top"><span class="code">
customPaint(...)
</span></td>
                    <td>
                        This paint method is called after the network graph has been drawn. It allows for
                        customizing the drawing of the graph by painting additional information onto the graphics.
                    </td>
                </tr>

                <tr>
                    <td valign="top"><span class="code">
handleEmptyEventQueue()
</span></td>
                    <td>
                        The framework calls this method when running in asynchronous mode and
                        there is no event left in the queue. You may generate new events in
                        this method to keep the simulation going.

                        <p>Note that the batch mode terminates when the event queue is
                            emptied and this method does not insert any new events.
                    </td>
                </tr>

                <tr>
                    <td valign="top"><span class="code">
preRun()
</span></td>
                    <td>
                        Called <em>once</em> prior to starting the first round in
                        synchronous mode, or prior to executing the first event in
                        asynchronous mode. Use this method to initialize the simulation.
                    </td>
                </tr>

                <tr>
                    <td valign="top"><span class="code">
onExit()
</span></td>
                    <td>
                        Called by the framework before shutting down. To ensure that this
                        method is called in all cases, you should use <span
                            class="code">sinalgo.tools.Tools.exit()</span> to exit, instead of
                        <span class="code">System.exit()</span>.
                    </td>
                </tr>

                <tr>
                    <td valign="top"><span class="code">
preRound()
</span></td>
                    <td>
                        Called in synchronous mode prior to every round. This method may be
                        suited to perform statistics and write log-files.
                    </td>
                </tr>

                <tr>
                    <td valign="top"><span class="code">
postRound()
</span></td>
                    <td>
                        Called in synchronous mode after every round. This method may be
                        suited to perform statistics and write log-files.
                    </td>
                </tr>

                <tr>
                    <td valign="top"><span class="code">
checkProjectRequirements()
</span></td>
                    <td>
                        The framework calls this method at startup after having selected a
                        project to check whether the necessary requirements for this project
                        are given. For algorithms that only work correctly in synchronous
                        mode this method check that the user didn't try to execute it in
                        asynchronous mode. If the requirements are not met, you may call
                        <span class="code">sinalgo.tools.Tools.fatalError(String msg)</span>
                        to terminate the application with a fatal error.
                    </td>
                </tr>

                <tr>
                    <td valign="top"><span class="code">
nodeAddedEvent(Node n)
</span></td>
                    <td>
                        Called by the framework whenever a node is added to the
                        framework (which is done through the method <span class="code">Runtime.addNode(Node n)</span>).
                        This event may be useful for applications that need to update
                        some graph properties whenever a new node is added (e.g. by the user
                        through the GUI).
                        <p>Note that this method is also called individually for each node created through
                            the <span class="code">-gen</span> command-line tool, and when the user
                            creates nodes using the GUI menu.
                    </td>
                </tr>

                <tr>
                    <td valign="top"><span class="code">
nodeRemovedEvent(Node n)
</span></td>
                    <td>
                        Called by the framework whenever a node is removed from the
                        framework (which is done through the method <span class="code">Runtime.removeNode(Node n)</span>).
                        This event may be useful for applications that need to update
                        some graph properties whenever a node is removed (e.g. by the user
                        through the GUI).
                        <p>Note that this method is <em>not</em> called when the user removes
                            all nodes using the <span class="code">Runtime.clearAllNodes()</span> method.
                    </td>
                </tr>


            </table>
            <span class="caption">Methods you may overwrite in the project owned <span
                    class="code">CustomGlobal</span> class.</span>


            <div class="subsubBody">
                <h3>Stopping the Simulation</h3>
                <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

                Most importantly for the batch mode, the <span
                    class="code"><strong>hasTerminated()</strong></span> method in the <span
                    class="code">CustomGlobal</span> class lets you specify whether a
                <em>synchronous</em> simulation has reached the final state and the
                framework may exit. See the <a class="nav_link"
                                               href="Implementation.html#Sync Call Sequence">calling
                sequence</a> of the synchronous mode for details on when <span
                    class="code">hasTerminated()</span> is called.

                In asynchronous simulation, the simulation terminates when all events
                have been handled. To stop execution prior to handling all events, or
                at an arbitrary place in synchronous mode, call <span
                    class="code"><strong>sinalgo.tools.Tools.exit()</strong></span>. This method
                executes some cleanup and is preferred to calling <span
                    class="code">System.exit()</span>. In particular, <span
                    class="code">sinalgo.tools.Tools.exit()</span> calls <span
                    class="code">AbstractCustomGlobal.<strong>onExit()</strong></span>, which you
                may overwrite in your project specific <span
                    class="">CustomGlobal.java</span> file.

                <p><strong>Hint:</strong> The <span class="code">onExit()</span> method may be
                    a good place to perform final logging steps and project specific
                    cleanup.
            </div>


            <div class="subsubBody">
                <h3>Project Specific Drop Down Methods and Buttons</h3>
                <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

                You may extend the GUI with project specific drop down menus and
                buttons: Add a dummy-method that takes no parameters to your <span
                    class="code">CustomGlobal</span> and implement the desired behavior
                in its body. There are three different ways to register the method
                with the GUI:

                <p><strong>1) Drop Down Menu Entry:</strong> Prefix the method with the annotation
                    <span class="code">@AbstractCustomGlobal.GlobalMethod</span> and
                    specify the <span class="code">menuText</span>. E.g.
                    <br>
                <div class="code codeTab">
                    @AbstractCustomGlobal.GlobalMethod( menuText="Toggle TC view")<br>
                    public void myMenuMethod() {<br>
                    <div class="codeTab">// ...</div>
                    }
                </div>

                <p><strong>2) Icon Button:</strong> Prefix the method with the annotation <span
                        class="code">@AbstractCustomGlobal.CustomButton</span> and specify
                    the <span class="code">imageName</span> and <span
                            class="code">toolTipText</span>. The <span
                            class="code">imageName</span> should be the name of a <span
                            class="code">gif</span> image of size 21x21 pixels, located in the
                    <span class="code">images</span> folder of the project.
                    E.g.
                    <br>
                <div class="code codeTab">
                    @CustomButton( imageName="myImage.gif", toolTipText="Click me!")<br>
                    public void myImageButtonMethod() {<br>
                    <div class="codeTab">// ...</div>
                    }
                </div>

                <p><strong>3) Text Button:</strong> Prefix the method with the annotation <span
                        class="code">@AbstractCustomGlobal.CustomButton</span> and specify
                    the <span class="code">buttonText</span> and <span
                            class="code">toolTipText</span>. E.g.
                    <br>
                <div class="code codeTab">
                    @CustomButton( buttonText="Clear", toolTipText="Click me!")<br>
                    public void myTextButtonMethod() {<br>
                    <div class="codeTab">// ...</div>
                    }
                </div>

                <p>
                <table border="0">
                    <tr>
                        <td>
                            <img src="../pics/customMenu.png" alt="Image of Menu">
                            <br><span class="caption">Project specific menu</span>
                        </td>
                        <td>
                            <img src="../pics/customButtons.png" alt="Image of buttons">
                            <br><span class="caption">Project specific buttons</span>
                        </td>
                    </tr>
                </table>

                <br>
                <p>The drop down menu entries (but not the buttons) may be adapted at
                    runtime: Every time the user opens the 'Global' menu,
                    the menu is assembled and includes methods annotated
                    with the <span class="code">GlobalMethod</span> annotation. Before including such a
                    method in the list, the framework calls
                    <span class="code">AbstractCustomGlobal.includeGlobalMethodInMenu(Method m, String defaultText)</span>
                    to allow the project to decide at runtime whether the method should be included or not, and,
                    if necessary, change the default menu text.
                <p>Overwrite the method <span
                        class="code">includeGlobalMethodInMenu(Method m, String defaultText)</span>
                    in your project specific <span class="code">CustomGlobal.java</span> file to control the appearance
                    of the 'Global' menu at runtime. The method returns the text to be displayed for each method, or
                    <span class="code">null</span> if the method should not be included.

            </div> <!-- End of subsubSection-->

        </td>
        <td><img src="../pics/spacer.gif" width="30" height="1" alt=""></td>
    </tr>
</table>

<table border="0" cellspacing="0" cellpadding="0" width="99%" align="center">
    <tr>
        <td style="font-size:8pt;" align="right" nowrap><br><br>&copy; <a href="http://www.disco.ethz.ch/"
                                                                          style="font-size:8pt;">Distributed Computing
            Group</a>
            <br>

            <a href="https://github.com/andrebrait/sinalgo"><img
                    src="../pics/GitHub-Mark-120px-plus.png"
                    height="25" border="0" alt="GitHub.com Mark"></a>
            <a href="https://github.com/andrebrait/sinalgo"><img
                    src="../pics/GitHub_Logo.png"
                    height="25" border="0" alt="GitHub.com Logo"></a>
            <a href="https://sourceforge.net/projects/sinalgo/"><img
                    src="https://sflogo.sourceforge.net/sflogo.php?group_id=192227&amp;type=1" width="88" height="31"
                    border="0" alt="SourceForge.net Logo"></a>
            <a href="https://jigsaw.w3.org/css-validator/check/referer"> <img
                    style="border:0;width:44px;height:16px"
                    src="../pics/vcss.png" alt="Valid CSS!">
            </a>
            <a href="https://validator.w3.org/check?uri=referer"><img
                    src="../pics/valid-html401.png"
                    style="border:0;width:44px;height:16px"
                    alt="Valid HTML 4.01 Transitional"></a>
        </td>
    </tr>
</table>

</body>
</html>
