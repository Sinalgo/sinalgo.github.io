<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!--suppress CheckImageSize -->
<html>
<head>
    <title>Sinalgo</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="keywords"
          content="roger wattenhofer, wattenhofer, distributed computing, simulation, network algorithm, validation, Sinalgo">
    <link REL="SHORTCUT ICON" href="../pics/favicon.ico">
    <link rel=stylesheet href="../style.css" type="text/css">


    <script type="text/javascript" language="JavaScript"><!--
    function setup() {
        if (!document.all) {
            document.getElementById("menu").style.top = window.pageYOffset.toString();
        }
        if (document.all) {
            document.all["menu"].style.top = document.body.scrollTop.toString();
        }
        window.setTimeout("setup()", 10);
    }

    //-->
    </script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=UA-120259448-1"></script>
    <script type="text/javascript">
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }

        gtag('js', new Date());

        gtag('config', 'UA-120259448-1');
    </script>

</head>

<body class="text" bgcolor="#FFFFFF" onload="setup()">
<table align="center" width="100%" style="margin-bottom:0"
       cellpadding="0" cellspacing="0" border="0">
    <tr class="height80">
        <td><img src="../pics/spacer.gif" width="210" height="80"
                 alt=""></td>
        <td width="100%">
            <h1 align="center">Sinalgo - <span class="red">Si</span>mulator for <span class="red">N</span>etwork <span
                    class="red">Algo</span>rithms</h1>
        </td>
    </tr>
    <tr class="height2">
        <td colspan="2" class="horizontalLine"></td>
    </tr>
</table>

<table border="0" cellspacing="0" cellpadding="0" class="showEmptyCells">
    <tr class="height10">
        <td width="210"></td>
        <td width="2" class="verticalLine"><img src="../pics/blac_vert_line.gif"
                                                width="2" height="1" alt=""></td>
        <td></td>
        <td colspan="2" align="right" valign="bottom"></td>
    </tr>

    <tr valign="top">
        <td>
            <div id='menu' style='position:absolute; visibility:visible; top:0;'>
                <table border="0" cellspacing="0" width="210">
                    <tr class="height80">
                        <td><a href="http://disco.ethz.ch/" target="_blank"><img
                                src="../pics/dcgWhite.png"
                                alt="Distributed Computing Group" border="0" height="50" width="160"></a></td>
                    </tr>
                    <tr class="height30">
                        <td><img src="../pics/spacer.gif" width="210" height="1" alt="">
                        <td>
                    </tr>
                    <tr>
                        <td class='menu'><a href='../index.html' class='menuLink'>Home</a></td>
                    </tr>
                    <tr>
                        <td class='menu'><a href='../news.html' class='menuLink'>News</a></td>
                    </tr>
                    <tr>
                        <td class='menu'><a href='../download.html' class='menuLink'>Download</a></td>
                    </tr>
                    <tr>
                        <td class='menu'><a href='Documentation.html' class='menuLink'>Tutorial</a></td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Documentation.html' class='SubMenuLink'>Getting
                            Started</a></td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Installation.html' class='SubMenuLink'>Installation</a>
                        </td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Execution.html' class='SubMenuLink'>Execution</a></td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Project.html' class='SubMenuLink'>Projects</a></td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Implementation.html' class='SubMenuLink'>Node
                            Implementation</a></td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Models.html' class='SubMenuLink'>Model Implementation</a>
                        </td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Configuration.html' class='SubMenuLink'>Configuration</a>
                        </td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Tools.html' class='SubMenuLink'>Tools</a></td>
                    </tr>
                    <tr>
                        <td class='subMenu'><a href='Architecture.html' class='selected_SubMenuLink'>Architecture</a>
                        </td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Architecture.html#Node Storage' class='SubSubMenuLink'>Node
                            Storage</a></td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Architecture.html#Sync vs Async'
                                                  class='SubSubMenuLink'>Sync vs Async</a></td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Architecture.html#Message Delivery'
                                                  class='SubSubMenuLink'>Message Delivery</a></td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Architecture.html#Edges'
                                                  class='SubSubMenuLink'>Edges</a></td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Architecture.html#Interference' class='SubSubMenuLink'>Interference</a>
                        </td>
                    </tr>
                    <tr>
                        <td class='subsubMenu'><a href='Architecture.html#Memory Management'
                                                  class='SubSubMenuLink'>Memory Management</a></td>
                    </tr>
                    <tr>
                        <td class='menu'><a href='../faq.html' class='menuLink'>FAQ</a></td>
                    </tr>
                    <tr>
                        <td class='menu'><a href='../contact.html' class='menuLink'>Contact</a></td>
                    </tr>
                </table>
            </div>
            <img src="../pics/spacer.gif" width="210" height="1" alt="">
        </td>
        <td width="2" class="verticalLine"><img src="../pics/blac_vert_line.gif"
                                                width="2" height="1" alt=""></td>
        <td><img src="../pics/spacer.gif" width="30" height="1" alt=""></td>

        <td class="bodyText" width="100%">

            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
            <h1>Insight Into the Clockwork of Sinalgo</h1>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            Sinalgo is a simulation framework that helps you simulate computer
            networks in different scenarios. Its main target networks are
            wireless networks, which are well described by the message passing
            model.

            <p>While running any simulation, it is crucial to understand how the
                simulation simplifies from a real network. For example, Sinalgo simulates the physical propagation of
                transmissions only very
                superficially (in contrast to other simulators, such as ns2). In the
                remainder of this section, we describe the operating mode of
                Sinalgo on a high level. We stick as close as possible to the
                implementation, such that the simplifications/abstractions from
                reality can be easily spotted.

                <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
            <h2>Node Storage<a name="Node Storage"></a></h2>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            Many connectivity models such as UDG and QUDG have a well defined
            upper bound on the Euclidean distance between two connected
            nodes. Sinalgo uses this upper bound to speed up the connectivity model,
            which determines the set of neighbors to each node. (Remember that
            the connectivity model is called in every <a
                href="Implementation.html#Sync Call Sequence"
                class="nav_link">round</a> of the synchronous simulation, and makes
            up a considerable part of the simulation time.) When the connectivity
            model is called for a given node <span class="code">n</span>, it
            could test whether <span class="code">n</span> is connected to any of
            the other nodes. However, if there is an upper bound on the Euclidean
            distance between any two connected nodes, it is sufficient to test a
            subset of nodes in an Euclidean proximity of <span
                class="code">n</span>, which corresponds to a range query.

            <p>Sinalgo provides support to perform range queries, which return a set
                of potential neighbors for a given node. To perform these range
                queries, Sinalgo stores the nodes in a specialized data structure. In
                the default distribution, Sinalgo stores the nodes in a <span
                        class="code">GeometricNodeCollection</span>, which implements the
                <span class="code">NodeCollectionInterface</span>.

                Because these range queries depend on the maximum distance between
                any two connected nodes, the <span
                        class="code">GeometricNodeCollection</span> needs to be configured
                through the project configuration file. It requires an entry of
                the following form, where <span class="code">rMax</span> specifies
                the maximum distance between any two connected nodes.

                <br>
            <div class="code codeTab"><strong>
                &lt;GeometricNodeCollection rMax="150"/&gt;
            </strong></div>

            <p>The <span class="code">NodeCollectionInterface</span> interface
                provides a method <span
                        class="code">getPossibleNeighborsEnumeration(Node n)</span>, which
                returns an enumeration over all potential neighbors of a given
                node. Using this method, the connectivity model only needs to test a
                subset of all nodes, which increases the simulation time
                considerably. The <a href="Models.html#Connectivity Model"
                                     class="nav_link">ConnectivityModelHelper</a> located in the
                package <span class="code">sinalgo.models</span> gives an example on how
                to use this range query.

            <p class="note"><strong>Note: </strong>The <span
                    class="code">GeometricNodeCollection</span> comes in two flavors, one
                for 2D and one for 3D. However, you may implement your own subclass
                of <span class="code">NodeCollectionInterface</span> to obtain range
                queries that depend on other criteria. The project configuration file
                contains an entry which specifies the node collection implementation
                to use.</p>

            <p class="note"><strong>Implementation Note: </strong> The <span
                    class="code">GeometricNodeCollection</span> partitions the deployment
                area in a 2-dimensional (3-dimensional) grid with cell-size <span
                        class="code">rMax</span>. Each cell stores the nodes that are
                contained within its boundaries. Whenever a node moves into a different
                cell, this data structure is updated to reflect the new situation. A
                range query for a given node <span class="code">n</span> determines
                the cell <span class="code">c</span> in which <span
                        class="code">n</span> is located, and returns the nodes contained in
                <span class="code">c</span> and any cell adjacent to <span
                        class="code">c</span>. Thus, <span
                        class="code">getPossibleNeighborsEnumeration(Node n)</span> returns
                the nodes contained in 9 cells in 2D, and the content of 27 cells in
                3D.</p>

            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
            <h2>Synchronous vs Asynchronous Mode<a name="Sync vs Async"></a></h2>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            Most importantly, Sinalgo either runs as an asynchronous, event
            triggered simulator, or in synchronous mode, where events happen in
            parallel in fixed time slots. The two modes result in different
            calling sequences of the methods implemented by the network
            nodes. The calling sequences are described in the <a
                href="Implementation.html#Sync Call Sequence"
                class="nav_link">Node Implementation tutorial</a>.

            <p>The simulation mode determines when exactly the method <span
                    class="code">handleMessage()</span> is called when a node receives a
                message, and when exactly the timers are fired when they expired.</p>

            <div class="subsubbody">
                <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
                <h3>Synchronous Simulation</h3>
                <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

                The synchronous simulation is based on <em>rounds</em>. At the
                beginning of each round, the framework increments the global time by
                one unit. Then, it moves the nodes according to their mobility models
                and updates the connections according to the connectivity
                model. After that, the framework iterates over the set of nodes and
                performs the method <span class="code">step()</span> on each
                node. The calling sequence of this method is described in the <a
                    href="Implementation.html#Sync Call Sequence"
                    class="nav_link">Node Implementation tutorial</a>. The nodes are
                visited in a framework specific order, which the simulation should
                not rely on.

                <p>Each message and timer carries a time stamp that indicates at
                    which time the event (arrival of message, execution of timer-handler)
                    should happen. Because the time advances in steps of 1 unit, each
                    node handles in its <span class="code">step()</span> method all
                    events whose time stamp is smaller or equal to the current time. For
                    both, the set of messages and the set of timers, the node sorts the
                    events according to their time stamp, such that the events happen in
                    order on each individual node.

                <p class="note"><strong>Note:</strong> From a global view, the message
                    receptions and timer-handlers may not be executed <em>in order</em>:
                    Suppose the case where node A receives a message M1 at 15.23 and M2
                    at 15.88 and node B receives a message M3 at 15.17 and M4 at
                    15.77. If the framework first executes the step() method on node A,
                    then the messages M1 and M2 are handled prior to the messages M3 and
                    M4, which are only handled in the call to step() of node B.
                </p>

                <p class="note"><strong>Implementation Note:</strong> If your project simulates
                    mobile nodes, the position of the nodes is updated at the beginning
                    of every round. As a result, the nodes hop around, which does not
                    quite correspond a continuous path. To achieve a better
                    approximation, you may increase the time resolution of the simulation
                    by a given factor, e.g. 10: Decrease the node speed by this factor,
                    and increase the message delivery time, as well as the countdown-time
                    of all timers by the same factor. This inserts several (in this case
                    9) more rounds for the same distance a node moves, which gives a
                    better approximation of the movement.</p>
            </div>

            <div class="subsubbody">
                <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
                <h3>Asynchronous Simulation</h3>
                <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

                The asynchronous simulation is purely event based. The framework
                holds a list of message events and timer events, which is sorted by
                the time when these events should happen (arrival of message,
                execution of timer-handler). The framework repeatedly picks the most
                recent event and executes it.

                <p>In a typical simulation, some of the events issue further events,
                    which prevent the event list from draining. If the list empties
                    anyways, the framework calls the <span
                            class="code">handleEmptyEventQueue</span> method of the project's
                    <span class="code">CustomGlobal</span> class. This method may issue
                    further events to continue the simulation.
            </div>

            <p>In general, the asynchronous simulation mode runs much faster than
                the synchronous mode. The main reason lies in the fact that the
                synchronous simulation mode loops over all nodes and performs for
                each node the <span class="code">step()</span> method even if most of
                the nodes may not do anything at all. This is in sharp contrast to
                the asynchronous mode, where only message and timer events are
                processed and no unnecessary cycles are wasted. But to achieve its
                speed, the asynchronous mode is more limited: it does not support
                mobility. I.e. the nodes cannot change their position over time. (The
                framework configuration entry <span class="code">mobility</span>
                needs to be set to <span class="code">false</span>, such that the
                mobility model assigned to each node is not considered.) The reason
                for this limitation on the asynchronous mode is the continuity of the
                node movement, which does not allow to be described in terms of
                events. (Note that also the synchronous mode does not perform
                continuous moves, but moves the nodes in hops at the beginning of
                every round.)

                <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
            <h2>Message Delivery<a name="Message Delivery"></a></h2>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            Whenever a node sends a message to another node of the network, the
            framework encapsulates the message object in a <em>packet</em> object,
            which contains the following meta information for the message
            delivery.
            <ul>
                <li>The sender of the message</li>
                <li>The receiver of the message</li>
                <li>The time when the message arrives</li>
                <li>The time when the message was sent</li>
                <li>The edge over which the message is being sent</li>
                <li>The intensity at which the message is being sent</li>
                <li>A unique ID for the packet</li>
            </ul>

            <p>The receiver of the message can retrieve this information for each
                received message in the <span class="code">handleMessages()</span>
                through the <span class="code">Inbox</span> object.

            <p>Project developers only get in touch with <span
                    class="code">Packet</span> objects when implementing a new
                interference model. The member
            <p><span class="code codeTab"><strong>public boolean</strong> positiveDelivery</span>
            <p>
                indicates whether the message hold in the packet will be received
                properly at the destination. If this flag is set to false, the
                receiving node will not include the corresponding message in the
                inbox, handed over to the <span class="code">handleMessages()</span>
                method.

            <p>Refer to the <a class="nav_link"
                               href="Implementation.html#Messages">Node Implementation</a>
                part of this tutorial for more information on how to implement
                project specific messages.

                <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
            <h2>Network Edges<a name="Edges"></a></h2>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            In the network abstraction of Sinalgo, an edge is present between any
            two nodes in communication range. The <a class="nav_link"
                                                     href="Models.html#Connectivity Model">Connectivity
            Model</a>
            is responsible to decide which node pairs are within communication
            range. Each node carries a list of its <em>outgoing
            connections</em>. I.e. the set of edges through which the node is
            connected to its direct neighbors. Because the edges are
            <em>unidirectional</em>, an edge object is contained in exactly one set
            of outgoing connections. Furthermore, if two nodes are connected in
            both directions, there are <em>two</em> edge objects, one hold by each
            end node.

            <p>Sinalgo requires that the <em>same</em> edge object is present between
                two nodes until the connection breaks. Upon reconnection of the two
                nodes, a new edge object has to be used. To distinguish edges, each
                edge object carries a <em>unique ID</em>.

            <p>The <span class="code">send</span> and <span
                    class="code">broadcast</span> methods provided by the node superclass
                deliver messages only if the sending node has an outgoing edge to the
                destination. The method <span class="code">sendDirect</span> is an
                exception: it is the only method that does not test whether the sender
                and receiver are really interconnected. This latter method may be
                used to simulate a wired overlay network, or to send messages between
                network nodes that are connected through another means.

            <p><strong>Note:</strong> Especially when manually adding an edge
                in GUI mode, remember that the added edge is
                <em>unidirectional</em>. To connect two nodes A and B in both
                direction, you need to add an edge from A to B, and another edge from
                B to A. To avoid this issue, you may want to use bidirectional edges.</p>

            <div class="subsubBody">
                <h3>Bidirectional Edges</h3>
                <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

                The use of unidirectional links may be desirable to simulate lossy
                and unpredictable networks. However, one may often want to abstract
                from these low-level issues and only consider bidirectional links. To
                ensure, that there is either no link at all between two nodes, or a
                link in both directions (a bidirectional link), use the <span
                    class="code">BidirectionalEdge</span>. This edge implementation
                automatically ensures that there is an edge in both directions
                between a given pair of nodes.

                <p>To implement bidirectional edges, and to draw edges properly, each
                    edge (not only the bidirectional ones) has a member <span
                            class="code">oppositeEdge</span>, which points to the edge that
                    connects the two end-nodes in the opposite direction, or is null, if
                    there is no such edge.
                </p>
            </div>

            <div class="subsubBody">
                <h3>Edge Creation, <span class="code">valid</span> Flag</h3>
                <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

                At any time, Sinalgo uses the <em>same edge type for all edges</em> - the
                framework holds one global factory that creates the new edges. The
                type of edges to be used is defined in the configuration file, and
                may be changed at runtime. But note that when changing the edge type
                at runtime, the existing edge objects are not replaced and thus
                implement the previous edge type. A change of the edge time at
                runtime only affects edges that are added to the network graph
                afterwards.

                <p>We have seen that the <a class="nav_link"
                                            href="Models.html#Connectivity Model">Connectivity Model</a>
                    determines to which other nodes a given node N is connected by adding
                    and removing edges from the <span
                            class="code">outgoingConnections</span> list of N. In most cases,
                    this model is too powerful, and the simpler <span
                            class="code">ConnectivityModelHelper</span> class can be used, where
                    the subclass only needs to answer whether node N is connected to
                    another node B. If node N has a (unidirectional) connection to node
                    A, the model calls <span class="code">N.outgoingConnections.add(N, B,
 true);</span>, which adds an edge NB to the set of outgoing
                    connections of node N. If the edge already exists, the call to <span
                            class="code">add</span> does <em>not</em> replace the existing edge.

                <p>The removal of the edges is somewhat more involved, because Sinalgo requires the <em>same</em> edge
                    object
                    to remain installed until the
                    corresponding connection breaks up. Therefore, we may not just empty
                    the set of outgoing connections before calling the connectivity
                    model. Sinalgo proposes to handle this issue using the <span
                            class="code">valid</span> member of each edge: Whenever the
                    connectivity model calls <span
                            class="code">N.outgoingConnections.add(N,B,true)</span> to ensure
                    that there is an edge NB, the <span class="code">valid</span> flag of
                    the added (or already existing) edge is set to true. Before the
                    connectivity model returns, it calls
                    N.outgoingConnections.removeInvalidLinks(), which iterates over all
                    outgoing edges of N and removes the ones whose <span
                            class="code">valid</span> flag is false. (At the same time, the
                    method resets the <span class="code">valid</span> flags to false for
                    the next round.)
                </p>
            </div>


            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
            <h2>Interference<a name="Interference"></a></h2>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            Computing the interference created by a set of network nodes can be
            quite a challenge, especially if real physical characteristics of the
            wireless transportation medium, perhaps even reflection are
            considered. Sinalgo offers a simplified view of the node signals which
            may cause interference. At any point in time, the framework holds a
            list of all messages that are being sent at that time. This list is
            called <span class="code">PacketsInTheAir</span> and may be accessed
            through <span
                class="code">Tools.getPacketsInTheAir()</span>. Note that this
            list only contains the packets if interference is enabled in the
            configuration file.

            <p>Each sender node can send its message with a given signal power,
                which we call <em>intensity</em>. The interference model can use the
                set of all messages and their corresponding intensity to determine
                the noise-level a given receiver node experiences.

            <p>One example is the SINR interference model, which assumes a signal
                decay exponential to the Euclidean distance to the sender. Roughly
                speaking, SINR drops a message if the signal of the message at the
                receiver is below the sum of all interfering signals times a given
                constant. A sample implementation of SINR is provided in the <span
                        class="code">defaultProject</span>.


                <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
            <h2>Memory Management<a name="Memory Management"></a></h2>
            <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

            Our choice to use Java was mainly based on its platform independence,
            modularity, and its wide acceptance. However, running a simulation in
            the Java environment quickly brings up memory problems, mainly
            related to garbage collection.

            <p>It seems that Java's garbage collector (GC) has a hard time when
                the application constantly creates a huge amount of small, short
                living objects. But that's exactly what our simulation framework
                does: For every message that is being sent, there are at least two
                new objects allocated, and if the network graph changes frequently,
                many edge objects need to be allocated.

            <p>To alleviate this problem, Sinalgo tries to <em>recycle</em> objects as
                often as possible: Instead of returning a removed edge to the GC,
                Sinalgo stores the edge object for reuse the next time an edge object of
                this type is needed. The same holds for the packets, which
                encapsulate the messages sent by the nodes. After a message arrived
                at its destination, the corresponding packet object is returned to
                Sinalgo for storage. Whenever a message is sent, Sinalgo only creates a new
                packet object if there is no recycled packet left.

            <p class="note"><strong>Note:</strong> Remind from the <a class="nav_link"
                                                                      href="Implementation.html#Messages">message
                implementation
                section</a> that a sent message object is cloned by default. To save
                memory, a project may apply a read-only policy for all messages, in
                which case the cloning of the messages can be circumvented. This
                preserves a lot of memory, especially for broadcast messages.</p>
        </td>
        <td><img src="../pics/spacer.gif" width="30" height="1" alt=""></td>
    </tr>
</table>

<table border="0" cellspacing="0" cellpadding="0" width="99%" align="center">
    <tr>
        <td style="font-size:8pt;" align="right" nowrap><br><br>&copy; <a href="http://www.disco.ethz.ch/"
                                                                          style="font-size:8pt;">Distributed Computing
            Group</a>
            <br>

            <a href="https://github.com/andrebrait/sinalgo"><img
                    src="../pics/GitHub-Mark-120px-plus.png"
                    height="25" border="0" alt="GitHub.com Mark"></a>
            <a href="https://github.com/andrebrait/sinalgo"><img
                    src="../pics/GitHub_Logo.png"
                    height="25" border="0" alt="GitHub.com Logo"></a>
            <a href="https://sourceforge.net/projects/sinalgo/"><img
                    src="https://sflogo.sourceforge.net/sflogo.php?group_id=192227&amp;type=1" width="88" height="31"
                    border="0" alt="SourceForge.net Logo"></a>
            <a href="https://jigsaw.w3.org/css-validator/check/referer"> <img
                    style="border:0;width:44px;height:16px"
                    src="../pics/vcss.png" alt="Valid CSS!">
            </a>
            <a href="https://validator.w3.org/check?uri=referer"><img
                    src="../pics/valid-html401.png"
                    style="border:0;width:44px;height:16px"
                    alt="Valid HTML 4.01 Transitional"></a>
        </td>
    </tr>
</table>

</body>
</html>
